package template

import (
	"context"
	"fmt"
	"path/filepath"

	. "github.com/dave/jennifer/jen"
	mstrings "github.com/valerylobachev/microgen/generator/strings"
	"github.com/valerylobachev/microgen/generator/write_strategy"
	"github.com/vetcher/go-astra/types"
)

var (
	defaultProtoTypes = []string{"string", "bool", "byte", "int64", "uint64", "float64", "int32", "uint32", "float32"}
	goToProtoTypesMap = map[string]string{
		"uint": "uint64",
		"int":  "int64",
	}
	defaultGolangTypes = []string{"string", "bool", "int", "uint", "byte", "int64", "uint64", "float64", "int32", "uint32", "float32"}
)

type gRPCEndpointConverterTemplate struct {
	info             *GenerationInfo
	requestEncoders  []*types.Function
	requestDecoders  []*types.Function
	responseEncoders []*types.Function
	responseDecoders []*types.Function
	state            WriteStrategyState
}

func NewGRPCEndpointConverterTemplate(info *GenerationInfo) Template {
	return &gRPCEndpointConverterTemplate{
		info: info,
	}
}

func decodeRequestName(f *types.Function) string {
	return "_Decode_" + f.Name + "_Request"
}

func decodeResponseName(f *types.Function) string {
	return "_Decode_" + f.Name + "_Response"
}

func encodeRequestName(f *types.Function) string {
	return "_Encode_" + f.Name + "_Request"
}

func encodeResponseName(f *types.Function) string {
	return "_Encode_" + f.Name + "_Response"
}

// Renders converter file.
//
//	// This file was automatically generated by "microgen" utility.
//	// DO NOT EDIT.
//	package protobuf
//
//	import (
//		context "context"
//		svc "github.com/valerylobachev/microgen/examples/svc"
//		stringsvc "gitlab.devim.team/protobuf/stringsvc"
//	)
//
//	func EncodeCountRequest(_ context.Context, request interface{}) (interface{}, error) {
//		req := request.(*svc.CountRequest)
//		return &stringsvc.CountRequest{
//			Symbol: req.Symbol,
//			Text:   req.Text,
//		}, nil
//	}
//
//	func EncodeCountResponse(_ context.Context, response interface{}) (interface{}, error) {
//		resp := response.(*svc.CountResponse)
//		respPositions, err := IntListToProto(resp.Positions)
//		if err != nil {
//			return nil, err
//		}
//		return &stringsvc.CountResponse{
//			Count:     int64(resp.Count),
//			Positions: respPositions,
//		}, nil
//	}
//
//	func DecodeCountRequest(_ context.Context, request interface{}) (interface{}, error) {
//		req := request.(*stringsvc.CountRequest)
//		return &svc.CountRequest{
//			Symbol: string(req.Symbol),
//			Text:   string(req.Text),
//		}, nil
//	}
//
//	func DecodeCountResponse(_ context.Context, response interface{}) (interface{}, error) {
//		resp := response.(*stringsvc.CountResponse)
//		respPositions, err := ProtoToIntList(resp.Positions)
//		if err != nil {
//			return nil, err
//		}
//		return &svc.CountResponse{
//			Count:     int(resp.Count),
//			Positions: respPositions,
//		}, nil
//	}
func (t *gRPCEndpointConverterTemplate) Render(ctx context.Context) write_strategy.Renderer {
	f := &Statement{}

	for _, signature := range t.requestEncoders {
		f.Line().Add(t.encodeRequest(ctx, signature))
	}
	for _, signature := range t.responseEncoders {
		f.Line().Add(t.encodeResponse(ctx, signature))
	}
	for _, signature := range t.requestDecoders {
		f.Line().Add(t.decodeRequest(ctx, signature))
	}
	for _, signature := range t.responseDecoders {
		f.Line().Add(t.decodeResponse(ctx, signature))
	}

	if t.state == AppendStrat {
		return f
	}

	file := NewFile("transportgrpc")
	file.HeaderComment(t.info.FileHeader)
	file.PackageComment(`Please, do not change functions names!`)
	file.ImportAlias(t.info.ProtobufPackageImport, "pb")
	file.Add(f)

	return file
}

const (
	iPointer   = "Ptr"
	iList      = "List"
	iSlice     = "List"
	iMap       = "Map"
	iInterface = "Interface"
	iToProto   = "ToProto"
	iProtoTo   = "ProtoTo"
	iEllipsis  = "El"
)

// Returns FieldTypeToProto.
func typeToProto(field types.Type, depth int) string {
	methodName := ""
Loop:
	for field != nil {
		switch f := field.(type) {
		case types.TImport:
			if f.Import != nil {
				methodName += mstrings.ToUpperFirst(f.Import.Name)
			}
			field = f.Next
		case types.TName:
			methodName += mstrings.ToUpperFirst(f.TypeName)
			field = nil
		case types.TArray:
			if f.IsSlice {
				methodName += iSlice
			} else if f.ArrayLen > 0 {
				methodName += iList
			}
			field = f.Next
		case types.TMap:
			methodName += iMap + typeToProto(f.Key, 1) + typeToProto(f.Value, 1)
			field = nil
		case types.TPointer:
			if f.NumberOfPointers > 1 {
				methodName += fmt.Sprintf("%sX%d", iPointer, f.NumberOfPointers)
			} else {
				methodName += iPointer
			}
			field = f.Next
		case types.TInterface:
			methodName += iInterface
			field = nil
		case types.TEllipsis:
			methodName += iEllipsis
			field = f.Next
		default:
			break Loop
		}
	}
	if depth == 0 {
		methodName += iToProto
	}
	return methodName
}

// Returns ProtoToFieldType.
func protoToType(field types.Type, depth int) string {
	methodName := ""
	if depth == 0 {
		methodName += iProtoTo
	}
Loop:
	for field != nil {
		switch f := field.(type) {
		case types.TImport:
			if f.Import != nil {
				methodName += mstrings.ToUpperFirst(f.Import.Name)
			}
			field = f.Next
		case types.TName:
			methodName += mstrings.ToUpperFirst(f.TypeName)
			field = nil
		case types.TArray:
			if f.IsSlice {
				methodName += iSlice
			} else if f.ArrayLen > 0 {
				methodName += iList
			}
			field = f.Next
		case types.TMap:
			methodName += iMap + typeToProto(f.Key, 1) + typeToProto(f.Value, 1)
			field = nil
		case types.TPointer:
			if f.NumberOfPointers > 1 {
				methodName += fmt.Sprintf("%sX%d", iPointer, f.NumberOfPointers)
			} else {
				methodName += iPointer
			}
			field = f.Next
		case types.TInterface:
			methodName += iInterface
			field = nil
		case types.TEllipsis:
			methodName += iEllipsis
			field = f.Next
		default:
			break Loop
		}
	}
	return methodName
}

func (gRPCEndpointConverterTemplate) DefaultPath() string {
	return filenameBuilder(PathTransport, "grpc", "protobuf_endpoint_converters")
}

func (t *gRPCEndpointConverterTemplate) Prepare(ctx context.Context) error {
	if t.info.ProtobufPackageImport == "" {
		return ErrProtobufEmpty
	}
	for _, fn := range t.info.Iface.Methods {
		if !t.info.AllowedMethods[fn.Name] {
			continue
		}
		t.requestDecoders = append(t.requestDecoders, fn)
		t.requestEncoders = append(t.requestEncoders, fn)
		t.responseDecoders = append(t.responseDecoders, fn)
		t.responseEncoders = append(t.responseEncoders, fn)
	}
	return nil
}

func (t *gRPCEndpointConverterTemplate) ChooseStrategy(ctx context.Context) (write_strategy.Strategy, error) {
	if err := statFile(t.info.OutputFilePath, t.DefaultPath()); err != nil {
		t.state = FileStrat
		return write_strategy.NewCreateFileStrategy(t.info.OutputFilePath, t.DefaultPath()), nil
	}
	file, err := parsePackage(filepath.Join(t.info.OutputFilePath, t.DefaultPath()))
	if err != nil {
		return nil, err
	}

	removeAlreadyExistingFunctions(file.Functions, &t.requestEncoders, encodeRequestName)
	removeAlreadyExistingFunctions(file.Functions, &t.requestDecoders, decodeRequestName)
	removeAlreadyExistingFunctions(file.Functions, &t.responseEncoders, encodeResponseName)
	removeAlreadyExistingFunctions(file.Functions, &t.responseDecoders, decodeResponseName)

	t.state = AppendStrat
	return write_strategy.NewAppendToFileStrategy(t.info.OutputFilePath, t.DefaultPath()), nil
}

func isPointer(p types.Type) bool {
	pp, ok := p.(types.TPointer)
	return ok && pp.NumberOfPointers == 1
}

// Renders type conversion (if need) to default protobuf types.
//
//	req.Symbol
//
// or
//
//	int(resp.Count)
//
// or
//
//	structNamePositions
//
// based on field type
// Second result means can field converts to default protobuf type.
func golangTypeToProto(ctx context.Context, structName string, field *types.Variable) (*Statement, bool) {
	if types.IsArray(field.Type) || isPointer(field.Type) {
		return Id(structName + mstrings.ToUpperFirst(field.Name)), false
	} else if isDefaultProtoField(field) {
		return Id(structName).Dot(mstrings.ToUpperFirst(field.Name)), true
	}
	name := types.TypeName(field.Type)
	if name == nil {
		return Id(structName + mstrings.ToUpperFirst(field.Name)), false
	}
	if newType, ok := goToProtoTypesMap[*name]; ok {
		var newField types.Type
		newField = types.TName{
			TypeName: newType,
		}
		if imp := types.TypeImport(field.Type); imp != nil {
			newField = types.TImport{
				Next:   newField,
				Import: imp,
			}
		}
		return fieldType(ctx, newField, false).Call(Id(structName).Dot(mstrings.ToUpperFirst(field.Name))), true
	}
	return Id(structName + mstrings.ToUpperFirst(field.Name)), false
}

// Renders type conversion to default golang types.
//
//	int(resp.Count)
//
// or
//
//	structNamePositions
//
// based on field type
// Second result means can field converts to golang type.
func protoTypeToGolang(ctx context.Context, structName string, field *types.Variable) (*Statement, bool) {
	if types.IsArray(field.Type) || isPointer(field.Type) {
		return Id(structName + mstrings.ToUpperFirst(field.Name)), false
	} else if isDefaultGolangField(field) {
		return fieldType(ctx, field.Type, false).Call(Id(structName).Dot(mstrings.ToUpperFirst(field.Name))), true
	}
	return Id(structName + mstrings.ToUpperFirst(field.Name)), false
}

func isDefaultProtoField(field *types.Variable) bool {
	name := types.TypeName(field.Type)
	return name != nil && mstrings.IsInStringSlice(*name, defaultProtoTypes)
}

func isDefaultGolangField(field *types.Variable) bool {
	name := types.TypeName(field.Type)
	return name != nil && mstrings.IsInStringSlice(*name, defaultGolangTypes)
}

// Render custom type converting and error checking
//
//	structNamePositions, err := ProtoToIntList(structName.Positions)
//	if err != nil {
//		return nil, err
//	}
func convertCustomType(structName, converterName string, field *types.Variable) *Statement {
	return List(Id(structName+mstrings.ToUpperFirst(field.Name)), Err()).
		Op(":=").
		Add(
			Id(converterName).Call(
				Id(structName).Dot(mstrings.ToUpperFirst(field.Name)),
			),
		).
		Line().If(Err().Op("!=").Nil()).Block(
		Return().List(Nil(), Err()),
	)
}

// Renders function for encoding request, golang type converts to proto type.
//
//	func EncodeCountRequest(_ context.Context, request interface{}) (interface{}, error) {
//		req := request.(*svc.CountRequest)
//		return &stringsvc.CountRequest{
//			Symbol: req.Symbol,
//			Text:   req.Text,
//		}, nil
//	}
func (t *gRPCEndpointConverterTemplate) encodeRequest(ctx context.Context, signature *types.Function) *Statement {
	methodParams := RemoveContextIfFirst(signature.Args)
	fullName := "request"
	shortName := "req"
	return Line().Func().Id(encodeRequestName(signature)).Params(ctx_contextContext, Id(fullName).Interface()).
		Params(Interface(), Error()).BlockFunc(
		func(group *Group) {
			if len(methodParams) == 1 {
				sp := specialEndpointConverterToProto(methodParams[0], signature, requestStructName, t.info.SourcePackageImport, fullName, shortName)
				if sp != nil {
					group.Add(sp)
					return
				}
			}
			if len(methodParams) > 0 {
				group.If(Id(fullName).Op("==").Nil()).Block(
					Return(Nil(), Qual(PackagePathErrors, "New").Call(Lit("nil "+requestStructName(signature)))),
				)
				group.Id(shortName).Op(":=").Id(fullName).Assert(Op("*").Qual(t.info.OutputPackageImport+"/transport", requestStructName(signature)))
				for _, field := range methodParams {
					if _, ok := golangTypeToProto(ctx, "", &field); !ok {
						group.Add(convertCustomType(shortName, typeToProto(field.Type, 0), &field))
					}
				}
			}
			group.Return().List(t.grpcEndpointConvReturn(ctx, signature, methodParams, requestStructName, shortName, golangTypeToProto, t.info.ProtobufPackageImport), Nil())
		},
	).Line()
}

// PackagePathEmptyProtobuf
func (t *gRPCEndpointConverterTemplate) grpcEndpointConvReturn(
	ctx context.Context,
	fn *types.Function,
	methodParams []types.Variable,
	strNameFn func(*types.Function) string,
	rec string,
	typeToProtoFn func(context.Context, string, *types.Variable) (*Statement, bool),
	pkg string,
) *Statement {
	if len(methodParams) == 0 {
		return Op("&").Qual(PackagePathEmptyProtobuf, "Empty").Values()
	}
	return Op("&").Qual(pkg, strNameFn(fn)).Values(DictFunc(func(dict Dict) {
		for _, field := range methodParams {
			req, _ := typeToProtoFn(ctx, rec, &field)
			dict[structFieldName(&field)] = Line().Add(req)
		}
	}))
}

// Renders function for encoding response, golang type converts to proto type.
//
//	func EncodeCountResponse(_ context.Context, response interface{}) (interface{}, error) {
//		resp := response.(*svc.CountResponse)
//		respPositions, err := IntListToProto(resp.Positions)
//		if err != nil {
//			return nil, err
//		}
//		return &stringsvc.CountResponse{
//			Count:     int64(resp.Count),
//			Positions: respPositions,
//		}, nil
//	}
func (t *gRPCEndpointConverterTemplate) encodeResponse(ctx context.Context, signature *types.Function) *Statement {
	methodResults := removeErrorIfLast(signature.Results)
	fullName := "response"
	shortName := "resp"
	return Line().Func().Id(encodeResponseName(signature)).Call(ctx_contextContext, Id(fullName).Interface()).Params(Interface(), Error()).BlockFunc(
		func(group *Group) {
			if len(methodResults) == 1 {
				sp := specialEndpointConverterToProto(methodResults[0], signature, responseStructName, t.info.SourcePackageImport+"/transport", fullName, shortName)
				if sp != nil {
					group.Add(sp)
					return
				}
			}
			if len(methodResults) > 0 {
				group.If(Id(fullName).Op("==").Nil()).Block(
					Return(Nil(), Qual(PackagePathErrors, "New").Call(Lit("nil "+responseStructName(signature)))),
				)
				group.Id(shortName).Op(":=").Id(fullName).Assert(Op("*").Qual(t.info.OutputPackageImport+"/transport", responseStructName(signature)))
				for _, field := range methodResults {
					if _, ok := golangTypeToProto(ctx, "", &field); !ok {
						group.Add(convertCustomType(shortName, typeToProto(field.Type, 0), &field))
					}
				}
			}
			group.Return().List(t.grpcEndpointConvReturn(ctx, signature, methodResults, responseStructName, shortName, golangTypeToProto, t.info.ProtobufPackageImport), Nil())
		},
	).Line()
}

// Renders function for decoding request, proto type converts to golang type.
//
//	func DecodeCountRequest(_ context.Context, request interface{}) (interface{}, error) {
//		req := request.(*stringsvc.CountRequest)
//		return &svc.CountRequest{
//			Symbol: string(req.Symbol),
//			Text:   string(req.Text),
//		}, nil
//	}
func (t *gRPCEndpointConverterTemplate) decodeRequest(ctx context.Context, signature *types.Function) *Statement {
	methodParams := RemoveContextIfFirst(signature.Args)
	fullName := "request"
	shortName := "req"
	return Line().Func().Id(decodeRequestName(signature)).Call(ctx_contextContext, Id(fullName).Interface()).Params(Interface(), Error()).BlockFunc(
		func(group *Group) {
			if len(methodParams) == 1 {
				sp := specialEndpointConverterFromProto(methodParams[0], signature, requestStructName, t.info.SourcePackageImport, fullName, shortName)
				if sp != nil {
					group.Add(sp)
					return
				}
			}
			if len(methodParams) > 0 {
				group.If(Id(fullName).Op("==").Nil()).Block(
					Return(Nil(), Qual(PackagePathErrors, "New").Call(Lit("nil "+requestStructName(signature)))),
				)
				group.Id(shortName).Op(":=").Id(fullName).Assert(Op("*").Qual(t.info.ProtobufPackageImport, requestStructName(signature)))
				for _, field := range methodParams {
					if _, ok := protoTypeToGolang(ctx, "", &field); !ok {
						group.Add(convertCustomType(shortName, protoToType(field.Type, 0), &field))
					}
				}
			}
			group.Return().List(t.grpcEndpointConvReturn(ctx, signature, methodParams, requestStructName, shortName, protoTypeToGolang, t.info.OutputPackageImport+"/transport"), Nil())
		},
	).Line()
}

// Renders function for decoding response, proto type converts to golang type.
//
//	func DecodeCountResponse(_ context.Context, response interface{}) (interface{}, error) {
//		resp := response.(*stringsvc.CountResponse)
//		respPositions, err := ProtoToIntList(resp.Positions)
//		if err != nil {
//			return nil, err
//		}
//		return &svc.CountResponse{
//			Count:     int(resp.Count),
//			Positions: respPositions,
//		}, nil
//	}
func (t *gRPCEndpointConverterTemplate) decodeResponse(ctx context.Context, signature *types.Function) *Statement {
	methodResults := removeErrorIfLast(signature.Results)
	fullName := "response"
	shortName := "resp"
	return Line().Func().Id(decodeResponseName(signature)).Call(ctx_contextContext, Id(fullName).Interface()).Params(Interface(), Error()).BlockFunc(
		func(group *Group) {
			if len(methodResults) == 1 {
				sp := specialEndpointConverterFromProto(methodResults[0], signature, responseStructName, t.info.SourcePackageImport+"/transport", fullName, shortName)
				if sp != nil {
					group.Add(sp)
					return
				}
			}
			if len(methodResults) > 0 {
				group.If(Id(fullName).Op("==").Nil()).Block(
					Return(Nil(), Qual(PackagePathErrors, "New").Call(Lit("nil "+responseStructName(signature)))),
				)
				group.Id(shortName).Op(":=").Id(fullName).Assert(Op("*").Qual(t.info.ProtobufPackageImport, responseStructName(signature)))
				for _, field := range methodResults {
					if _, ok := protoTypeToGolang(ctx, "", &field); !ok {
						group.Add(convertCustomType(shortName, protoToType(field.Type, 0), &field))
					}
				}
			}
			group.Return().List(t.grpcEndpointConvReturn(ctx, signature, methodResults, responseStructName, shortName, protoTypeToGolang, t.info.OutputPackageImport+"/transport"), Nil())
		},
	).Line()
}

func specialEndpointConverterToProto(
	v types.Variable,
	fn *types.Function,
	strNameFn func(*types.Function) string,
	pkg string,
	fullName string,
	shortName string,
) *Statement {
	name := types.TypeName(v.Type)
	imp := types.TypeImport(v.Type)
	// *string -> *wrappers.StringValue
	if name != nil && *name == "string" && imp == nil {
		_, ok := v.Type.(types.TPointer)
		if ok {
			s := If(Id(fullName).Op("==").Nil()).Block(
				Return(Nil(), Nil()),
			)
			sp := Op("*").Qual(pkg, strNameFn(fn))
			s.Line().Id(shortName).Op(":=").Id(fullName).Assert(sp)
			s.Line().Return(Op("&").Qual(GolangProtobufWrappers, "StringValue").Values(Dict{Id("Value"): Op("*").Id(shortName).Op(".").Add(structFieldName(&v))}), Nil())
			return s
		}
	}
	return nil
}

func specialEndpointConverterFromProto(
	v types.Variable,
	fn *types.Function,
	strNameFn func(*types.Function) string,
	pkg string,
	fullName string,
	shortName string,
) *Statement {
	name := types.TypeName(v.Type)
	imp := types.TypeImport(v.Type)
	// *string <- *wrappers.StringValue
	if name != nil && *name == "string" && imp == nil {
		_, ok := v.Type.(types.TPointer)
		if ok {
			s := If(Id(fullName).Op("==").Nil()).Block(
				Return(Nil(), Nil()),
			)
			sp := Op("*").Qual(GolangProtobufWrappers, "StringValue")
			s.Line().Id(shortName).Op(":=").Id(fullName).Assert(sp)
			s.Line().Return(Op("&").Qual(pkg, strNameFn(fn)).Values(Dict{structFieldName(&v): Op("&").Id(shortName).Dot("Value")}), Nil())
			return s
		}
	}
	return nil
}
