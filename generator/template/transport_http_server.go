package template

import (
	"context"
	"path"
	"path/filepath"
	"regexp"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/samber/lo"
	mstrings "github.com/valerylobachev/microgen/generator/strings"
	"github.com/valerylobachev/microgen/generator/write_strategy"
	"github.com/vetcher/go-astra/types"
)

const (
	defaultHTTPMethod = "POST"

	HttpMethodTag  = "http-method"
	HttpMethodPath = "http-path"
	HttpQueryVars  = "http-query-vars"
	HttpBody       = "http-body"
)

type httpServerTemplate struct {
	info    *GenerationInfo
	methods map[string]string
	paths   map[string]string
	vars    map[string]httpVars
}

type httpVars struct {
	path  []string
	query []string
	body  string
}

func (h httpVars) HasQuery() bool {
	return len(h.query) != 0
}

func (h httpVars) HasPath() bool {
	return len(h.path) != 0
}

func (h httpVars) HasBody() bool {
	return len(h.body) != 0
}

func NewHttpServerTemplate(info *GenerationInfo) Template {
	return &httpServerTemplate{
		info: info,
	}
}

func (t *httpServerTemplate) DefaultPath() string {
	return filenameBuilder(PathTransport, "http", "server")
}

func (t *httpServerTemplate) ChooseStrategy(ctx context.Context) (write_strategy.Strategy, error) {
	return write_strategy.NewCreateFileStrategy(t.info.OutputFilePath, t.DefaultPath()), nil
}

func (t *httpServerTemplate) Prepare(ctx context.Context) error {
	t.methods = make(map[string]string)
	t.paths = make(map[string]string)
	t.vars = make(map[string]httpVars)
	urlPrefix := strings.Replace(mstrings.FetchMetaInfo(TagMark+HttpMethodPath, t.info.Iface.Docs), " ", "", -1)

	for _, fn := range t.info.Iface.Methods {
		t.methods[fn.Name] = FetchHttpMethodTag(fn.Docs)
		t.paths[fn.Name] = buildMethodPath(fn, urlPrefix)
		t.vars[fn.Name] = *buildHttpVars(fn)
	}
	return nil
}

func buildHttpVars(fn *types.Function) *httpVars {
	vars := httpVars{
		path:  make([]string, 0),
		query: make([]string, 0),
		body:  "",
	}
	// extract query vars
	s := strings.Split(
		strings.TrimSpace(mstrings.FetchMetaInfo(TagMark+HttpQueryVars, fn.Docs)),
		" ",
	)
	vars.query = lo.Filter[string](s, func(v string, _ int) bool { return len(v) != 0 })
	// extract path vars
	url := strings.Replace(mstrings.FetchMetaInfo(TagMark+HttpMethodPath, fn.Docs), " ", "", -1)
	r := regexp.MustCompile(`\{(.*?)\}`)
	vars.path = lo.Map[string](r.FindAllString(url, -1), func(v string, _ int) string {
		return strings.Trim(strings.Trim(v, "{"), "}")
	})
	// extract body
	vars.body = strings.TrimSpace(strings.Replace(mstrings.FetchMetaInfo(TagMark+HttpBody, fn.Docs), " ", "", -1))
	return &vars
}

func FetchHttpMethodTag(rawString []string) string {
	tags := mstrings.FetchTags(rawString, TagMark+HttpMethodTag)
	if len(tags) == 1 {
		return strings.ToTitle(tags[0])
	}
	return defaultHTTPMethod
}

func buildMethodPath(fn *types.Function, urlPrefix string) string {
	url := strings.Replace(mstrings.FetchMetaInfo(TagMark+HttpMethodPath, fn.Docs), " ", "", -1)
	if url == "" {
		url = buildDefaultMethodPath(fn)
	}
	if urlPrefix == "" {
		return url
	} else {
		return urlPrefix + "/" + url
	}
}

func buildDefaultMethodPath(fn *types.Function) string {
	edges := []string{mstrings.ToURLSnakeCase(fn.Name)} // parts of full path
	if FetchHttpMethodTag(fn.Docs) == "GET" {
		edges = append(edges, gorillaMuxUrlTemplateVarList(RemoveContextIfFirst(fn.Args))...)
	}
	return path.Join(edges...)
}

func gorillaMuxUrlTemplateVarList(vars []types.Variable) []string {
	var list []string
	for i := range vars {
		list = append(list, "{"+mstrings.ToURLSnakeCase(vars[i].Name)+"}")
	}
	return list
}

// Render http server constructor.
//
//	// This file was automatically generated by "microgen" utility.
//	// DO NOT EDIT.
//	package transporthttp
//
//	import (
//		svc "github.com/valerylobachev/microgen/examples/svc"
//		http2 "github.com/valerylobachev/microgen/examples/svc/transport/converter/http"
//		http "github.com/go-kit/kit/transport/http"
//		http1 "net/http"
//	)
//
//	func NewHTTPHandler(endpoints *svc.Endpoints, opts ...http.ServerOption) http1.Handler {
//		handler := http1.NewServeMux()
//		handler.Handle("/test_case", http.NewServer(
//			endpoints.TestCaseEndpoint,
//			http2.DecodeHTTPTestCaseRequest,
//			http2.EncodeHTTPTestCaseResponse,
//			opts...))
//		handler.Handle("/empty_req", http.NewServer(
//			endpoints.EmptyReqEndpoint,
//			http2.DecodeHTTPEmptyReqRequest,
//			http2.EncodeHTTPEmptyReqResponse,
//			opts...))
//		handler.Handle("/empty_resp", http.NewServer(
//			endpoints.EmptyRespEndpoint,
//			http2.DecodeHTTPEmptyRespRequest,
//			http2.EncodeHTTPEmptyRespResponse,
//			opts...))
//		return handler
//	}
func (t *httpServerTemplate) Render(ctx context.Context) write_strategy.Renderer {
	f := NewFile("transporthttp")
	f.ImportAlias(t.info.SourcePackageImport, serviceAlias)
	f.HeaderComment(t.info.FileHeader)

	f.Func().Id("NewHTTPHandler").ParamsFunc(func(p *Group) {
		p.Id("endpoints").Op("*").Qual(t.info.OutputPackageImport+"/transport", EndpointsSetName)
		if Tags(ctx).Has(TracingMiddlewareTag) {
			p.Id("logger").Qual(PackagePathGoKitLog, "Logger")
		}
		if Tags(ctx).Has(TracingMiddlewareTag) {
			p.Id("tracer").Qual(PackagePathOpenTracingGo, "Tracer")
		}
		p.Id("opts").Op("...").Qual(PackagePathGoKitTransportHTTP, "ServerOption")
	}).Params(
		Qual(PackagePathHttp, "Handler"),
	).BlockFunc(func(g *Group) {
		g.Id("mux").Op(":=").Qual(PackagePathGorillaMux, "NewRouter").Call()
		for _, fn := range t.info.Iface.Methods {
			if !t.info.AllowedMethods[fn.Name] {
				continue
			}
			g.Id("mux").Dot("Methods").Call(Lit(t.methods[fn.Name])).Op(".")
			g.Id("Path").
				Call(Lit("/" + t.paths[fn.Name])).Dot("")
			if t.vars[fn.Name].HasQuery() {
				g.Id("Queries").CallFunc(func(g *Group) {
					for _, v := range t.vars[fn.Name].query {
						g.Lit(v)
						g.Lit("{" + v + "}")
					}
				}).Op(".")
			}
			g.Id("Handler").Call(
				Line().Qual(PackagePathGoKitTransportHTTP, "NewServer").Call(
					Line().Id("endpoints").Dot(endpointsStructFieldName(fn.Name)),
					Line().Id(decodeRequestName(fn)),
					Line().Id(encodeResponseName(fn)),
					Line().Add(t.serverOpts(ctx, fn)).Op("...")),
			)
		}
		g.Return(Id("mux"))
	})

	return f
}

func (t *httpServerTemplate) serverOpts(ctx context.Context, fn *types.Function) *Statement {
	s := &Statement{}
	if Tags(ctx).Has(TracingMiddlewareTag) {
		s.Op("append(")
		defer s.Op(")")
	}
	s.Id("opts")
	if Tags(ctx).Has(TracingMiddlewareTag) {
		s.Op(",").Qual(PackagePathGoKitTransportHTTP, "ServerBefore").Call(
			Line().Qual(PackagePathGoKitTracing, "HTTPToContext").Call(Id("tracer"), Lit(fn.Name), Id("logger")),
		)
	}
	return s
}

func pathToHttpConverter(servicePath string) string {
	return filepath.Join(servicePath, "transport/converter/http")
}
